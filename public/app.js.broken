class VideoKeyframeExtractor {
    constructor() {
        this.currentSessionId = null;
        this.isProcessing = false;
        this.abortController = null;
        this.currentProject = null; // Store current project data

        // Drawing elements
        this.drawingCanvas = document.getElementById('drawingCanvas');
        this.imageContainer = document.getElementById('imageContainer');
        this.drawingControls = document.getElementById('drawingControls');
        this.toggleDrawingBtn = document.getElementById('toggleDrawingBtn');
        this.clearDrawingBtn = document.getElementById('clearDrawingBtn');
        this.toggleNotesBtn = document.getElementById('toggleNotesBtn');
        this.brushSize = document.getElementById('brushSize');
        this.brushColor = document.getElementById('brushColor');

        // Drawing state
        this.isDrawing = false;
        this.drawingMode = false;
        this.notesVisible = true;
        this.drawingHistory = new Map(); // Store drawings per keyframe filename
        this.ctx = null;

        this.initializeElements();
        this.bindEvents();
        this.initializeView();
        this.initializeTheme();
        this.checkServerStatus();
        this.checkCookieStatus();
        this.checkProjectLoad(); // Check if loading an existing project
        this.initializeMouseTracking();
    }

    initializeElements() {
        // Sections
        this.uploadSection = document.getElementById('uploadSection');
        this.loadingSection = document.getElementById('loadingSection');
        this.resultsSection = document.getElementById('resultsSection');
        this.errorSection = document.getElementById('errorSection');

        // Forms and inputs
        this.urlForm = document.getElementById('urlForm');
        this.uploadForm = document.getElementById('uploadForm');
        this.videoUrlInput = document.getElementById('videoUrl');
        this.videoFileInput = document.getElementById('videoFile');
        this.fileDropArea = document.getElementById('fileDropArea');

        // Buttons
        this.urlSubmitBtn = document.getElementById('urlSubmitBtn');
        this.uploadSubmitBtn = document.getElementById('uploadSubmitBtn');
        this.cancelBtn = document.getElementById('cancelBtn');
        this.newExtractionBtn = document.getElementById('newExtractionBtn');
        this.retryBtn = document.getElementById('retryBtn');
        this.downloadAllBtn = document.getElementById('downloadAllBtn');
        this.saveProjectBtn = document.getElementById('saveProjectBtn');
        this.backToProjectsBtn = document.getElementById('backToProjectsBtn');

        // Tab navigation
        this.tabButtons = document.querySelectorAll('.tab-btn');
        this.tabContents = document.querySelectorAll('.tab-content');

        // Loading elements
        this.loadingText = document.getElementById('loadingText');
        this.progressFill = document.getElementById('progressFill');
        this.progressPercentage = document.getElementById('progressPercentage');

        // Results elements
        this.frameCount = document.getElementById('frameCount');
        this.gallery = document.getElementById('gallery');
        this.galleryContainer = document.getElementById('galleryContainer');
        this.sectionTitle = document.getElementById('sectionTitle');

        // Selection elements
        this.selectionInfo = document.getElementById('selectionInfo');
        this.selectedCount = document.getElementById('selectedCount');
        this.selectAllBtn = document.getElementById('selectAllBtn');
        this.deselectAllBtn = document.getElementById('deselectAllBtn');
        this.addNotesBtn = document.getElementById('addNotesBtn');
        this.deleteSelectedBtn = document.getElementById('deleteSelectedBtn');

        // Selection state
        this.selectedKeyframes = new Set();

        // Custom keyframe names
        this.keyframeNames = new Map();

        // Keyframe notes
        this.keyframeNotes = new Map();

        // Frame metadata for navigation
        this.frameMetadata = new Map(); // Maps filename to {timestamp, index, sessionId}
        this.videoDuration = null; // Store video duration for boundary checking
        this.frameCache = new Map(); // Cache for adjacent frames: Maps timestamp to {url, filename}

        // Navigation message debouncing
        this.navigationMessageTimeout = null;
        this.lastNavigationTime = 0;

        // Error elements
        this.errorMessage = document.getElementById('errorMessage');

        // Modal elements
        this.imageModal = document.getElementById('imageModal');
        this.modalBackdrop = document.getElementById('modalBackdrop');
        this.modalClose = document.getElementById('modalClose');
        this.modalImage = document.getElementById('modalImage');
        this.modalTitle = document.getElementById('modalTitle');
        this.downloadBtn = document.getElementById('downloadBtn');
        this.copyUrlBtn = document.getElementById('copyUrlBtn');
        this.saveFrameBtn = document.getElementById('saveFrameBtn');

        // Frame navigation elements
        this.framePrevBtn = document.getElementById('framePrevBtn');
        this.frameNextBtn = document.getElementById('frameNextBtn');

        // Frame progress elements
        this.frameProgress = document.getElementById('frameProgress');
        this.frameProgressFill = document.getElementById('frameProgressFill');
        this.frameTimeInfo = document.getElementById('frameTimeInfo');

        // Notes modal elements
        this.notesModal = document.getElementById('notesModal');
        this.notesModalBackdrop = document.getElementById('notesModalBackdrop');
        this.notesModalClose = document.getElementById('notesModalClose');
        this.notesModalTitle = document.getElementById('notesModalTitle');
        this.selectedFramesCount = document.getElementById('selectedFramesCount');
        this.notesTextarea = document.getElementById('notesTextarea');
        this.notesCharCount = document.getElementById('notesCharCount');
        this.saveNotesBtn = document.getElementById('saveNotesBtn');
        this.cancelNotesBtn = document.getElementById('cancelNotesBtn');

        // Add Keyframe button (now in bulk actions)
        this.addKeyframeBtn = document.getElementById('addKeyframeBtn');

        // Cookie management elements
        this.cookieFile = document.getElementById('cookieFile');
        this.uploadCookieBtn = document.getElementById('uploadCookieBtn');
        this.clearCookiesBtn = document.getElementById('clearCookiesBtn');
        this.cookieStatus = document.getElementById('cookieStatus');
        this.statusIndicator = document.getElementById('statusIndicator');
        this.statusText = document.getElementById('statusText');
        this.cookieActions = document.getElementById('cookieActions');
        this.cookieUploadArea = document.getElementById('cookieUploadArea');

        // Keyframe options elements
        this.urlMaxFrames = document.getElementById('urlMaxFrames');
        this.urlIncludeLastFrame = document.getElementById('urlIncludeLastFrame');
        this.uploadMaxFrames = document.getElementById('uploadMaxFrames');
        this.uploadIncludeLastFrame = document.getElementById('uploadIncludeLastFrame');

        // Storyboard view elements
        this.storyboardContainer = document.getElementById('storyboardContainer');
        this.storyboardSidebar = document.getElementById('storyboardSidebar');
        this.storyboardFrames = document.getElementById('storyboardFrames');
        this.storyboardMain = document.getElementById('storyboardMain');
        this.mainFrameContainer = document.getElementById('mainFrameContainer');
        this.mainFrameDetails = document.getElementById('mainFrameDetails');
        this.galleryViewBtn = document.getElementById('galleryViewBtn');
        this.storyboardViewBtn = document.getElementById('storyboardViewBtn');

        // Theme toggle elements
        this.themeToggle = document.getElementById('themeToggle');
        this.themeToggleLabel = document.getElementById('themeToggleLabel');
        this.themeIcon = document.getElementById('themeIcon');

        // Main header theme toggle elements
        this.mainThemeToggle = document.getElementById('mainThemeToggle');
        this.mainThemeToggleLabel = document.getElementById('mainThemeToggleLabel');
        this.mainThemeIcon = document.getElementById('mainThemeIcon');

        // Track selected storyboard frame
        this.selectedStoryboardFrame = null;
    }

    bindEvents() {
        // Tab navigation
        this.tabButtons.forEach(btn => {
            btn.addEventListener('click', () => this.switchTab(btn.dataset.tab));
        });

        // Form submissions
        this.urlForm.addEventListener('submit', (e) => this.handleUrlSubmit(e));
        this.uploadForm.addEventListener('submit', (e) => this.handleUploadSubmit(e));

        // File drag and drop
        this.bindFileDropEvents();

        // File input change
        this.videoFileInput.addEventListener('change', () => this.handleFileSelection());

        // Cookie management
        this.bindCookieEvents();

        // Button clicks
        this.cancelBtn.addEventListener('click', () => this.cancelProcessing());
        this.newExtractionBtn.addEventListener('click', () => this.resetToUpload());
        this.retryBtn.addEventListener('click', () => this.resetToUpload());
        this.downloadAllBtn.addEventListener('click', () => this.downloadAllKeyframes());
        this.saveProjectBtn.addEventListener('click', () => this.saveProject());
        this.backToProjectsBtn.addEventListener('click', () => this.goBackToProjects());

        // Selection buttons
        this.selectAllBtn.addEventListener('click', () => this.selectAllKeyframes());
        this.deselectAllBtn.addEventListener('click', () => this.deselectAllKeyframes());
        this.addNotesBtn.addEventListener('click', () => this.openNotesModal());
        this.deleteSelectedBtn.addEventListener('click', () => this.deleteSelectedKeyframes());

        // Add Keyframe button (Clone Selected)
        this.addKeyframeBtn.addEventListener('click', () => this.cloneSelectedKeyframes());

        // Modal events
        this.modalBackdrop.addEventListener('click', () => this.closeModal());
        this.modalClose.addEventListener('click', () => this.closeModal());
        this.downloadBtn.addEventListener('click', () => this.downloadCurrentImage());
        this.copyUrlBtn.addEventListener('click', () => this.copyImageUrl());
        this.saveFrameBtn.addEventListener('click', () => this.saveCurrentNavigationFrame());

        // Frame navigation events
        this.framePrevBtn.addEventListener('click', () => this.navigateFrame('prev'));
        this.frameNextBtn.addEventListener('click', () => this.navigateFrame('next'));

        // Notes modal events
        this.notesModalBackdrop.addEventListener('click', () => this.closeNotesModal());
        this.notesModalClose.addEventListener('click', () => this.closeNotesModal());
        this.saveNotesBtn.addEventListener('click', () => this.saveNotesToSelected());
        this.cancelNotesBtn.addEventListener('click', () => this.closeNotesModal());
        this.notesTextarea.addEventListener('input', () => this.updateNotesCharCount());

        // Keyboard events
        document.addEventListener('keydown', (e) => {
            if (e.key === 'Escape') {
                this.closeModal();
                this.closeNotesModal();
            }

            // Frame navigation with arrow keys
            if (!this.imageModal.classList.contains('hidden')) {
                if (e.key === 'ArrowLeft') {
                    e.preventDefault();
                    if (!this.framePrevBtn.disabled) {
                        this.navigateFrame('prev');
                    }
                } else if (e.key === 'ArrowRight') {
                    e.preventDefault();
                    if (!this.frameNextBtn.disabled) {
                        this.navigateFrame('next');
                    }
                }
                // Add spacebar for play/pause-like behavior (cycle between frames)
                else if (e.key === ' ') {
                    e.preventDefault();
                    if (!this.frameNextBtn.disabled) {
                        this.navigateFrame('next');
                    } else if (!this.framePrevBtn.disabled) {
                        this.navigateFrame('prev');
                    }
                }
            }
        });

        // Gallery scroll effects
        if (this.galleryContainer) {
            this.galleryContainer.addEventListener('scroll', () => this.handleGalleryScroll());
        }

        // View toggle events
        this.galleryViewBtn.addEventListener('click', () => this.switchView('gallery'));
        this.storyboardViewBtn.addEventListener('click', () => this.switchView('storyboard'));

        // Theme toggle events (with delayed binding to ensure elements exist)
        setTimeout(() => {
            const themeToggle = document.getElementById('themeToggle');
            const themeToggleLabel = document.getElementById('themeToggleLabel');
            const mainThemeToggle = document.getElementById('mainThemeToggle');
            const mainThemeToggleLabel = document.getElementById('mainThemeToggleLabel');

            if (themeToggle) {
                themeToggle.addEventListener('click', () => this.toggleTheme());
            }
            if (themeToggleLabel) {
                themeToggleLabel.addEventListener('click', () => this.toggleTheme());
            }
            if (mainThemeToggle) {
                mainThemeToggle.addEventListener('click', () => this.toggleTheme());
            }
            if (mainThemeToggleLabel) {
                mainThemeToggleLabel.addEventListener('click', () => this.toggleTheme());
            }
        }, 100);

        // Drawing events
        this.bindDrawingEvents();
    }

    initializeMouseTracking() {
        let mouseTimeout;

        document.addEventListener('mousemove', (e) => {
            // Update CSS custom properties for mouse position
            document.documentElement.style.setProperty('--mouse-x', e.clientX + 'px');
            document.documentElement.style.setProperty('--mouse-y', e.clientY + 'px');

            // Show gradient
            document.body.classList.add('mouse-active');

            // Clear timeout if it exists
            if (mouseTimeout) {
                clearTimeout(mouseTimeout);
            }

            // Hide gradient after 2 seconds of no movement
            mouseTimeout = setTimeout(() => {
                document.body.classList.remove('mouse-active');
            }, 2000);
        });

        // Hide gradient when mouse leaves the window
        document.addEventListener('mouseleave', () => {
            document.body.classList.remove('mouse-active');
            clearTimeout(mouseTimeout);
        });
    }

    initializeView() {
        // Check URL parameters for initial view
        const urlParams = new URLSearchParams(window.location.search);
        const requestedView = urlParams.get('view');
        const mode = urlParams.get('mode');

        // If coming from "Start from Scratch", switch to storyboard view
        if (requestedView === 'storyboard' && mode === 'scratch') {
            this.switchView('storyboard');
            // Hide upload section since we're starting from scratch
            this.uploadSection.style.display = 'none';
            this.resultsSection.style.display = 'block';
            // Initialize empty gallery for storyboard
            this.initializeEmptyStoryboard();
        } else {
            // Set gallery as the default view
            this.switchView('gallery');
        }
    }

    initializeEmptyStoryboard() {
        // Initialize empty storyboard interface
        this.frameCount.textContent = '0';

        // Clear any existing content
        if (this.gallery) {
            this.gallery.innerHTML = '';
        }

        // Show storyboard-specific UI elements
        if (this.storyboardContainer) {
            this.storyboardContainer.style.display = 'flex';
            this.storyboardContainer.classList.remove('hidden');
        }

        // Hide gallery-specific UI elements
        if (this.galleryContainer) {
            this.galleryContainer.style.display = 'none';
            this.galleryContainer.classList.add('hidden');
        }

        // Update view toggle buttons
        if (this.galleryViewBtn && this.storyboardViewBtn) {
            this.galleryViewBtn.classList.remove('active');
            this.storyboardViewBtn.classList.add('active');
        }

        // Initialize empty storyboard sidebar
        this.renderStoryboardSidebar();
    }

    toggleTheme() {
        const currentTheme = document.documentElement.getAttribute('data-theme');
        const newTheme = currentTheme === 'light' ? 'dark' : 'light';

        document.documentElement.setAttribute('data-theme', newTheme);
        this.updateThemeIcon(newTheme);

        // Save theme preference
        localStorage.setItem('theme', newTheme);
    }

    updateThemeIcon(theme) {
        if (this.themeIcon) {
            if (theme === 'light') {
                this.themeIcon.className = 'fas fa-sun';
            } else {
                this.themeIcon.className = 'fas fa-moon';
            }
        }

        if (this.mainThemeIcon) {
            if (theme === 'light') {
                this.mainThemeIcon.className = 'fas fa-sun';
            } else {
                this.mainThemeIcon.className = 'fas fa-moon';
            }
        }
    }

    initializeTheme() {
        // Get saved theme or default to dark
        const savedTheme = localStorage.getItem('theme') || 'dark';
        document.documentElement.setAttribute('data-theme', savedTheme);
        this.updateThemeIcon(savedTheme);
    }

    bindFileDropEvents() {
        // Prevent default drag behaviors
        ['dragenter', 'dragover', 'dragleave', 'drop'].forEach(eventName => {
            this.fileDropArea.addEventListener(eventName, this.preventDefaults, false);
            document.body.addEventListener(eventName, this.preventDefaults, false);
        });

        // Highlight drop area when item is dragged over it
        ['dragenter', 'dragover'].forEach(eventName => {
            this.fileDropArea.addEventListener(eventName, () => {
                this.fileDropArea.classList.add('drag-over');
            }, false);
        });

        ['dragleave', 'drop'].forEach(eventName => {
            this.fileDropArea.addEventListener(eventName, () => {
                this.fileDropArea.classList.remove('drag-over');
            }, false);
        });

        // Handle dropped files
        this.fileDropArea.addEventListener('drop', (e) => {
            const files = e.dataTransfer.files;
            if (files.length > 0) {
                this.handleFileSelection(files[0]);
            }
        }, false);

        // Handle click on drop area
        this.fileDropArea.addEventListener('click', () => {
            this.videoFileInput.click();
        });
    }

    bindCookieEvents() {
        // Cookie file selection
        this.cookieFile.addEventListener('change', () => {
            const file = this.cookieFile.files[0];
            if (file) {
                this.uploadCookieBtn.disabled = false;
                this.uploadCookieBtn.innerHTML = `<i class="fas fa-upload"></i> Upload ${file.name}`;
            } else {
                this.uploadCookieBtn.disabled = true;
                this.uploadCookieBtn.innerHTML = '<i class="fas fa-upload"></i> Upload Cookies';
            }
        });

        // Cookie upload button click
        this.uploadCookieBtn.addEventListener('click', (e) => {
            e.stopPropagation(); // Prevent event bubbling
            this.handleCookieUpload();
        });

        // Clear cookies
        this.clearCookiesBtn.addEventListener('click', () => this.handleClearCookies());

        // Cookie upload area click - delegate to specific areas that should trigger file input
        this.cookieUploadArea.addEventListener('click', (e) => {
            // Only trigger file dialog if clicking on:
            // 1. The upload area itself (not its children)
            // 2. The icon or text elements (but not the button)
            const targetElement = e.target;
            const isUploadButton = targetElement === this.uploadCookieBtn ||
                targetElement.closest('#uploadCookieBtn');
            const isFileInput = targetElement === this.cookieFile;

            // Don't trigger if clicking on button or file input directly
            if (isUploadButton || isFileInput) {
                return;
            }

            // Only trigger for clicks on the upload area background or text/icon elements
            const isClickableArea = targetElement === this.cookieUploadArea ||
                targetElement.classList.contains('cookie-upload-content') ||
                targetElement.tagName === 'I' ||
                targetElement.tagName === 'H4' ||
                (targetElement.tagName === 'P' && targetElement.textContent.includes('Export'));

            if (isClickableArea) {
                e.stopPropagation();
                this.cookieFile.click();
            }
        });
    }

    preventDefaults(e) {
        e.preventDefault();
        e.stopPropagation();
    }

    switchTab(tabName) {
        // Update tab buttons
        this.tabButtons.forEach(btn => {
            btn.classList.toggle('active', btn.dataset.tab === tabName);
        });

        // Update tab contents
        this.tabContents.forEach(content => {
            content.classList.toggle('active', content.id === `${tabName}Tab`);
        });
    } switchView(viewName) {
        // Update view toggle buttons
        this.galleryViewBtn.classList.toggle('active', viewName === 'gallery');
        this.storyboardViewBtn.classList.toggle('active', viewName === 'storyboard');

        // Show/hide appropriate containers
        if (viewName === 'gallery') {
            this.galleryContainer.style.display = 'block';
            this.galleryContainer.classList.remove('hidden');
            this.storyboardContainer.style.display = 'none';
            this.storyboardContainer.classList.add('hidden');
        } else {
            this.galleryContainer.style.display = 'none';
            this.galleryContainer.classList.add('hidden');
            this.storyboardContainer.style.display = 'flex';
            this.storyboardContainer.classList.remove('hidden');

            // Render storyboard if we have keyframes
            if (this.gallery && this.gallery.children.length > 0) {
                this.renderStoryboardSidebar();
                // Select first frame if none selected
                if (!this.selectedStoryboardFrame) {
                    const firstFrame = this.storyboardFrames.firstElementChild;
                    if (firstFrame) {
                        this.selectStoryboardFrame(firstFrame);
                    }
                }
            }
        }
    }

    // Drawing-related methods
    initializeDrawing() {
        if (!this.drawingCanvas) return;

        this.ctx = this.drawingCanvas.getContext('2d');
        this.drawingCanvas.width = this.imageContainer.clientWidth;
        this.drawingCanvas.height = this.imageContainer.clientHeight;

        // Load saved drawing if available
        const currentFilename = this.currentModalImage?.filename;
        if (currentFilename) {
            const savedDrawing = this.drawingHistory.get(currentFilename);
            if (savedDrawing) {
                this.loadDrawing(savedDrawing);
            }
        }
    }

    toggleDrawing() {
        this.drawingMode = !this.drawingMode;
        this.toggleDrawingBtn.classList.toggle('active', this.drawingMode);

        if (this.drawingMode) {
            this.startDrawing();
        } else {
            this.stopDrawing();
        }
    }

    startDrawing() {
        this.isDrawing = true;
        this.drawingCanvas.classList.remove('hidden');

        // Clear the canvas for new drawing
        const currentFilename = this.currentModalImage?.filename;
        if (currentFilename) {
            const savedDrawing = this.drawingHistory.get(currentFilename);
            if (savedDrawing) {
                this.loadDrawing(savedDrawing);
            } else {
                this.clearDrawing();
            }
        }
    }

    stopDrawing() {
        this.isDrawing = false;
        this.saveDrawing();

        // Optionally, hide the canvas after stopping
        // this.drawingCanvas.classList.add('hidden');
    }

    clearDrawing() {
        if (!this.ctx) return;

        // Clear the canvas
        this.ctx.clearRect(0, 0, this.drawingCanvas.width, this.drawingCanvas.height);
        this.drawingHistory.set(this.currentModalImage.filename, []);
    }

    changeBrushSize(size) {
        this.brushSize.value = size;
        this.ctx.lineWidth = size;
    }

    changeBrushColor(color) {
        this.brushColor.value = color;
        this.ctx.strokeStyle = color;
    }

    saveDrawing() {
        if (!this.currentModalImage || !this.ctx) return;

        const drawingData = this.ctx.getImageData(0, 0, this.drawingCanvas.width, this.drawingCanvas.height);
        this.drawingHistory.set(this.currentModalImage.filename, drawingData);
    }

    loadDrawing(drawingData) {
        if (!this.ctx) return;

        this.ctx.putImageData(drawingData, 0, 0);
    }

    // Other methods remain unchanged...
}

// Add CSS animations for notifications
const style = document.createElement('style');
style.textContent = `
    @keyframes slideInRight {
        from {
            transform: translateX(100%);
            opacity: 0;
        }
        to {
            transform: translateX(0);
            opacity: 1;
        }
    }
    
    @keyframes slideOutRight {
        from {
            transform: translateX(0);
            opacity: 1;
        }
        to {
            transform: translateX(100%);
            opacity: 0;
        }
    }
`;
document.head.appendChild(style);

// Initialize the application when DOM is loaded
document.addEventListener('DOMContentLoaded', () => {
    window.app = new VideoKeyframeExtractor();
});
